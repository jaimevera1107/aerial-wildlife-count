import json

# Leer el notebook existente
with open('src/v1/train_deformable_detr_colab.ipynb', 'r', encoding='utf-8') as f:
    notebook = json.load(f)

# Agregar las celdas faltantes
new_cells = [
    {
        'cell_type': 'markdown',
        'metadata': {},
        'source': ['## üìä Evaluaci√≥n y Visualizaci√≥n']
    },
    {
        'cell_type': 'code',
        'execution_count': None,
        'metadata': {},
        'outputs': [],
        'source': [
            '# Funci√≥n para evaluar el modelo entrenado\n',
            'def evaluate_model():\n',
            '    """Evaluar el modelo en el conjunto de test"""\n',
            '    \n',
            '    # Buscar el mejor checkpoint\n',
            '    checkpoint_dir = Path(detr_config.work_dir)\n',
            '    checkpoints = list(checkpoint_dir.glob("*.pth"))\n',
            '    \n',
            '    if not checkpoints:\n',
            '        print("‚ùå No se encontraron checkpoints")\n',
            '        return None\n',
            '    \n',
            '    # Usar el √∫ltimo checkpoint o el mejor\n',
            '    best_checkpoint = None\n',
            '    for ckpt in checkpoints:\n',
            '        if "best" in ckpt.name:\n',
            '            best_checkpoint = ckpt\n',
            '            break\n',
            '    \n',
            '    if not best_checkpoint:\n',
            '        best_checkpoint = sorted(checkpoints)[-1]  # √öltimo checkpoint\n',
            '    \n',
            '    print(f"üìä Evaluando con checkpoint: {best_checkpoint}")\n',
            '    \n',
            '    # Cargar modelo\n',
            '    model = init_detector(str(config_path), str(best_checkpoint), device=detr_config.device)\n',
            '    \n',
            '    # Evaluar en test\n',
            '    test_results = model.test(\n',
            '        data=mmdet_config.test_dataloader.dataset,\n',
            '        metric="bbox"\n',
            '    )\n',
            '    \n',
            '    print("‚úÖ Evaluaci√≥n completada")\n',
            '    return test_results, best_checkpoint\n',
            '\n',
            '# Ejecutar evaluaci√≥n si el entrenamiento fue exitoso\n',
            'if train_json and val_json and test_json:\n',
            '    try:\n',
            '        test_results, best_ckpt = evaluate_model()\n',
            '        print(f"üéØ Mejor checkpoint: {best_ckpt}")\n',
            '    except Exception as e:\n',
            '        print(f"‚ùå Error en evaluaci√≥n: {e}")'
        ]
    },
    {
        'cell_type': 'code',
        'execution_count': None,
        'metadata': {},
        'outputs': [],
        'source': [
            '# Funci√≥n para visualizar predicciones\n',
            'def visualize_predictions(model, image_path, save_path=None):\n',
            '    """Visualizar predicciones en una imagen"""\n',
            '    \n',
            '    # Realizar inferencia\n',
            '    result = inference_detector(model, image_path)\n',
            '    \n',
            '    # Visualizar\n',
            '    from mmdet.visualization import DetLocalVisualizer\n',
            '    visualizer = DetLocalVisualizer()\n',
            '    \n',
            '    # Cargar imagen\n',
            '    img = cv2.imread(str(image_path))\n',
            '    \n',
            '    # Mostrar predicciones\n',
            '    visualizer.add_datasample(\n',
            '        "result",\n',
            '        img,\n',
            '        data_sample=result,\n',
            '        draw_gt=False,\n',
            '        wait_time=0,\n',
            '        out_file=save_path\n',
            '    )\n',
            '    \n',
            '    return result\n',
            '\n',
            '# Funci√≥n para probar el modelo en im√°genes de ejemplo\n',
            'def test_model_on_samples():\n',
            '    """Probar el modelo en algunas im√°genes de ejemplo"""\n',
            '    \n',
            '    if not (train_json and val_json and test_json):\n',
            '        print("‚ùå No hay modelo entrenado para probar")\n',
            '        return\n',
            '    \n',
            '    # Usar el directorio de im√°genes de test ya determinado\n',
            '    if not test_img_dir.exists():\n',
            '        print("‚ùå No se encontr√≥ directorio de im√°genes de test")\n',
            '        return\n',
            '    \n',
            '    # Tomar algunas im√°genes de ejemplo\n',
            '    image_files = list(test_img_dir.glob("*.jpg"))[:3]  # Primeras 3 im√°genes\n',
            '    \n',
            '    if not image_files:\n',
            '        print("‚ùå No se encontraron im√°genes de test")\n',
            '        return\n',
            '    \n',
            '    print(f"üñºÔ∏è  Probando modelo en {len(image_files)} im√°genes...")\n',
            '    \n',
            '    # Cargar modelo\n',
            '    try:\n',
            '        model = init_detector(str(config_path), str(best_ckpt), device=detr_config.device)\n',
            '        \n',
            '        for i, img_path in enumerate(image_files):\n',
            '            print(f"  Procesando imagen {i+1}: {img_path.name}")\n',
            '            \n',
            '            # Visualizar predicciones\n',
            '            result = visualize_predictions(model, img_path)\n',
            '            \n',
            '            # Mostrar estad√≠sticas\n',
            '            if hasattr(result, "pred_instances"):\n',
            '                num_detections = len(result.pred_instances)\n',
            '                print(f"    Detecciones: {num_detections}")\n',
            '        \n',
            '        print("‚úÖ Pruebas completadas")\n',
            '        \n',
            '    except Exception as e:\n',
            '        print(f"‚ùå Error probando modelo: {e}")\n',
            '\n',
            '# Ejecutar pruebas si hay modelo entrenado\n',
            'test_model_on_samples()'
        ]
    },
    {
        'cell_type': 'markdown',
        'metadata': {},
        'source': ['## üíæ Guardar y Descargar Resultados']
    },
    {
        'cell_type': 'code',
        'execution_count': None,
        'metadata': {},
        'outputs': [],
        'source': [
            '# Funci√≥n para guardar resultados en Google Drive\n',
            'def save_to_drive():\n',
            '    """Guardar resultados del entrenamiento en Google Drive"""\n',
            '    \n',
            '    if not os.path.exists("/content/drive"):\n',
            '        print("‚ùå Google Drive no est√° montado")\n',
            '        return False\n',
            '    \n',
            '    # Crear directorio en Drive\n',
            '    drive_results_dir = "/content/drive/MyDrive/aerial-wildlife-count-results"\n',
            '    os.makedirs(drive_results_dir, exist_ok=True)\n',
            '    \n',
            '    # Copiar directorio de trabajo\n',
            '    import shutil\n',
            '    try:\n',
            '        shutil.copytree(detr_config.work_dir, f"{drive_results_dir}/deformable_detr_{detr_config.backbone}", dirs_exist_ok=True)\n',
            '        print(f"‚úÖ Resultados guardados en: {drive_results_dir}/deformable_detr_{detr_config.backbone}")\n',
            '        return True\n',
            '    except Exception as e:\n',
            '        print(f"‚ùå Error guardando en Drive: {e}")\n',
            '        return False\n',
            '\n',
            '# Funci√≥n para descargar archivos\n',
            'def download_results():\n',
            '    """Descargar archivos importantes del entrenamiento"""\n',
            '    \n',
            '    workdir = Path(detr_config.work_dir)\n',
            '    \n',
            '    # Archivos importantes a descargar\n',
            '    important_files = [\n',
            '        "config.py",\n',
            '        "*.log",\n',
            '        "*.pth"\n',
            '    ]\n',
            '    \n',
            '    print("üì• Descargando archivos importantes...")\n',
            '    \n',
            '    for pattern in important_files:\n',
            '        files_to_download = list(workdir.glob(pattern))\n',
            '        for file_path in files_to_download:\n',
            '            if file_path.is_file():\n',
            '                print(f"  Descargando: {file_path.name}")\n',
            '                files.download(str(file_path))\n',
            '\n',
            '# Opciones para guardar resultados\n',
            'print("üíæ Opciones para guardar resultados:")\n',
            'print("1. Guardar en Google Drive")\n',
            'print("2. Descargar archivos")\n',
            'print("3. Ambas opciones")\n',
            '\n',
            'choice = input("Selecciona opci√≥n (1, 2, o 3): ").strip()\n',
            '\n',
            'if choice in ["1", "3"]:\n',
            '    save_to_drive()\n',
            '\n',
            'if choice in ["2", "3"]:\n',
            '    download_results()\n',
            '\n',
            'if choice not in ["1", "2", "3"]:\n',
            '    print("‚ùå Opci√≥n inv√°lida")'
        ]
    }
]

# Insertar las nuevas celdas antes de la √∫ltima celda
notebook['cells'] = notebook['cells'][:-1] + new_cells + [notebook['cells'][-1]]

# Guardar el notebook actualizado
with open('src/v1/train_deformable_detr_colab.ipynb', 'w', encoding='utf-8') as f:
    json.dump(notebook, f, indent=1, ensure_ascii=False)

print('Secciones agregadas exitosamente')
