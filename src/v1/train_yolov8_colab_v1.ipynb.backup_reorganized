{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# üöÄ Entrenamiento YOLOv8 en Google Colab - V1 (Optimizado)\n",
    "\n",
    "Este notebook entrena un modelo YOLOv8 con Ultralytics en Google Colab para detecci√≥n de vida silvestre a√©rea.\n",
    "\n",
    "## üî• **MEJORAS V1:**\n",
    "- ‚úÖ **Guardado autom√°tico en Drive** cada X √©pocas\n",
    "- ‚úÖ **Recuperaci√≥n de entrenamiento** interrumpido\n",
    "- ‚úÖ **Configuraci√≥n optimizada** para velocidad\n",
    "- ‚úÖ **Monitoreo en tiempo real** del progreso\n",
    "- ‚úÖ **Backup autom√°tico** de checkpoints\n",
    "\n",
    "## üìã Caracter√≠sticas\n",
    "- **Modelo**: YOLOv8s, YOLOv8m, YOLOv8l, YOLOv8x\n",
    "- **Detecci√≥n autom√°tica de GPU**\n",
    "- **Conversi√≥n autom√°tica COCO a YOLO**\n",
    "- **Visualizaci√≥n de resultados**\n",
    "- **Exportaci√≥n a ONNX/TorchScript**\n",
    "- **An√°lisis de m√©tricas detallado**\n",
    "\n",
    "## üéØ Clases de Animales\n",
    "- Buffalo\n",
    "- Elephant  \n",
    "- Kob\n",
    "- Alcelaphinae\n",
    "- Warthog\n",
    "- Waterbuck\n",
    "\n",
    "## ‚öôÔ∏è Configuraci√≥n por Defecto\n",
    "- **Modelo**: YOLOv8s (balanceado entre velocidad y precisi√≥n)\n",
    "- **Tama√±o de imagen**: 640x640\n",
    "- **√âpocas**: 100\n",
    "- **Batch size**: 16\n",
    "- **Optimizador**: AdamW\n",
    "- **Mixed Precision**: Habilitado\n",
    "\n",
    "## üî¨ Ventajas de YOLOv8\n",
    "- **R√°pido**: Entrenamiento e inferencia eficientes\n",
    "- **Preciso**: Mejor rendimiento que versiones anteriores\n",
    "- **F√°cil de usar**: API simple de Ultralytics\n",
    "- **Flexible**: M√∫ltiples tama√±os de modelo"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# ============================================================\n",
    "# VARIABLES GLOBALES PARA BACKUP AUTOM√ÅTICO\n",
    "# ============================================================\n",
    "\n",
    "# Variables globales para el sistema de backup\n",
    "backup_thread_running = False\n",
    "backup_thread = None\n",
    "\n",
    "print(\"‚úÖ Variables globales de backup inicializadas\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## üìä Monitoreo en Tiempo Real\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Funciones de monitoreo en tiempo real\n",
    "def monitor_training_progress():\n",
    "    \"\"\"Monitorear el progreso del entrenamiento en tiempo real\"\"\"\n",
    "    try:\n",
    "        results_dir = Path(f\"{yolo_config.project}/{yolo_config.name}\")\n",
    "        \n",
    "        if not results_dir.exists():\n",
    "            print(\"‚ùå Directorio de resultados no encontrado\")\n",
    "            return\n",
    "        \n",
    "        # Verificar archivos de resultados\n",
    "        results_csv = results_dir / \"results.csv\"\n",
    "        if results_csv.exists():\n",
    "            import pandas as pd\n",
    "            df = pd.read_csv(results_csv)\n",
    "            if not df.empty:\n",
    "                latest_epoch = df.iloc[-1]\n",
    "                print(f\"üìä Progreso actual:\")\n",
    "                print(f\"  √âpoca: {latest_epoch.get('epoch', 'N/A')}\")\n",
    "                print(f\"  mAP: {latest_epoch.get('metrics/mAP50(B)', 'N/A'):.4f}\")\n",
    "                print(f\"  Loss: {latest_epoch.get('train/box_loss', 'N/A'):.4f}\")\n",
    "                print(f\"  Val Loss: {latest_epoch.get('val/box_loss', 'N/A'):.4f}\")\n",
    "        \n",
    "        # Verificar checkpoints\n",
    "        weights_dir = results_dir / \"weights\"\n",
    "        if weights_dir.exists():\n",
    "            checkpoints = list(weights_dir.glob(\"*.pt\"))\n",
    "            print(f\"üìÅ Checkpoints disponibles: {len(checkpoints)}\")\n",
    "            for ckpt in checkpoints:\n",
    "                size_mb = ckpt.stat().st_size / (1024 * 1024)\n",
    "                print(f\"  - {ckpt.name} ({size_mb:.1f} MB)\")\n",
    "        \n",
    "        # Verificar backups en Drive\n",
    "        backup_dir = Path(yolo_config.drive_backup_dir)\n",
    "        if backup_dir.exists():\n",
    "            backups = list(backup_dir.glob(\"epoch_*\"))\n",
    "            print(f\"üíæ Backups en Drive: {len(backups)}\")\n",
    "        \n",
    "    except Exception as e:\n",
    "        print(f\"‚ùå Error en monitoreo: {e}\")\n",
    "\n",
    "def get_training_status():\n",
    "    \"\"\"Obtener estado actual del entrenamiento\"\"\"\n",
    "    try:\n",
    "        results_dir = Path(f\"{yolo_config.project}/{yolo_config.name}\")\n",
    "        \n",
    "        if not results_dir.exists():\n",
    "            return \"No iniciado\"\n",
    "        \n",
    "        # Verificar si hay resultados\n",
    "        results_csv = results_dir / \"results.csv\"\n",
    "        if results_csv.exists():\n",
    "            import pandas as pd\n",
    "            df = pd.read_csv(results_csv)\n",
    "            if not df.empty:\n",
    "                latest_epoch = df.iloc[-1]['epoch']\n",
    "                total_epochs = yolo_config.epochs\n",
    "                progress = (latest_epoch / total_epochs) * 100\n",
    "                return f\"En progreso: {latest_epoch}/{total_epochs} √©pocas ({progress:.1f}%)\"\n",
    "        \n",
    "        return \"Iniciando\"\n",
    "        \n",
    "    except Exception as e:\n",
    "        return f\"Error: {e}\"\n",
    "\n",
    "def estimate_remaining_time():\n",
    "    \"\"\"Estimar tiempo restante de entrenamiento\"\"\"\n",
    "    try:\n",
    "        results_dir = Path(f\"{yolo_config.project}/{yolo_config.name}\")\n",
    "        results_csv = results_dir / \"results.csv\"\n",
    "        \n",
    "        if not results_csv.exists():\n",
    "            return \"No disponible\"\n",
    "        \n",
    "        import pandas as pd\n",
    "        df = pd.read_csv(results_csv)\n",
    "        \n",
    "        if len(df) < 2:\n",
    "            return \"Calculando...\"\n",
    "        \n",
    "        # Calcular tiempo promedio por √©poca basado en el n√∫mero de √©pocas\n",
    "        # Asumir que cada √©poca toma aproximadamente el mismo tiempo\n",
    "        current_epoch = df.iloc[-1]['epoch']\n",
    "        remaining_epochs = yolo_config.epochs - current_epoch\n",
    "        \n",
    "        # Estimaci√≥n simple: asumir 2-5 minutos por √©poca\n",
    "        estimated_minutes = remaining_epochs * 3  # 3 minutos promedio por √©poca\n",
    "        \n",
    "        if estimated_minutes < 60:\n",
    "            return f\"Tiempo estimado restante: {estimated_minutes:.0f} minutos\"\n",
    "        else:\n",
    "            hours = estimated_minutes / 60\n",
    "            return f\"Tiempo estimado restante: {hours:.1f} horas\"\n",
    "        \n",
    "    except Exception as e:\n",
    "        return f\"Error: {e}\"\n",
    "\n",
    "# Funci√≥n para mostrar estado completo\n",
    "def show_training_status():\n",
    "    \"\"\"Mostrar estado completo del entrenamiento\"\"\"\n",
    "    print(\"=\" * 60)\n",
    "    print(\"üìä ESTADO DEL ENTRENAMIENTO YOLOv8 V1\")\n",
    "    print(\"=\" * 60)\n",
    "    print(f\"Estado: {get_training_status()}\")\n",
    "    print(f\"Tiempo restante: {estimate_remaining_time()}\")\n",
    "    print()\n",
    "    monitor_training_progress()\n",
    "    print(\"=\" * 60)\n",
    "\n",
    "print(\"‚úÖ Funciones de monitoreo cargadas\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Ejecutar monitoreo en tiempo real\n",
    "print(\"üìä Sistema de monitoreo en tiempo real disponible\")\n",
    "print(\"üí° Usa 'show_training_status()' para ver el progreso durante el entrenamiento\")\n",
    "print(\"üí° Usa 'monitor_training_progress()' para ver detalles del progreso\")\n",
    "print(\"üí° Usa 'get_training_status()' para obtener el estado actual\")\n",
    "print(\"üí° Usa 'estimate_remaining_time()' para estimar tiempo restante\")\n",
    "print()\n",
    "print(\"‚úÖ Funciones de monitoreo cargadas y listas para usar\")\n"
   ]
  }
 ],
 "metadata": {
  "accelerator": "GPU",
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "name": "python",
   "version": "3.10.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}